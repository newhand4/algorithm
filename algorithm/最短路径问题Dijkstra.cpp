/**
* -*- coding : GBK -*-
* @Author : huangshengjiang
* @Email : 1005542693@qq.com
* @Date : 2017-05-03 09:51
* @Last Modified Date : 
* @FileName : 单点最短路径问题Dijkstra.cpp
*/

/*单点最短路径问题Dijkstra
基本概念 : 设G=(V,E)是一个每条边有非负长度的有向图,有一个特异顶点s称为源.单点最短路径问题是确定从s到V中每一个顶点的最短距离
应用场景 : 通信网络中源点到目的点的最短距离.
局限性 : 只知道距离,希望改进保留相应的路径.
	输入 : 含权有向图G=(V,E),V={1,2,...,n}
	输出 : G中顶点1到其他顶点的距离
例子 : 
	输入 : 6  9
		   1  2  1
		   1  3  12
		   2  4  3
		   2  3  9
		   3  5  5
		   4  3  4
		   4  5  13
		   4  6  15
		   5  6  4
 	输出 : D[2]=1 D[3]=8 D[4]=4 D[5]=13 D[6]=17


分析 : dijkstra算法的思想是
	   1.X表示已经分配的集合(用X[V]数组表示,X[i]=1表示第i个顶点在集合中,X[i]=0则相反),含{1},Y表示未分配的集合,含{V-1}.D[0..V]中的D[i]表示从顶点1到顶点i的最短距离.D[0]=D[1]= 0
		D[i]= INF(i = 2..V)
	   2.遍历u=1的所有边edge(1,v).计算D[1]+edge(1,v)和D[v]的大小,如果<,则更新D[v] = D[1]+edge(1,v)

	   3.遍历D数组,找出X[i]=0中D[i]最小的值.然后置X[i]=1,Y[i]=0,将u=i代入第2步中循环.(循环打破条件是X[i]都等于1)
时间复杂度 :
空间复杂度 :
简化 :

解决方案1 :
优缺点 :

解决方案2 :
优缺点 :

引申问题 :

方案对比 :

结论 :

*/
#include <iostream>
using namespace std;
//函数
//DIJSTRA

//测试
/*int main(int argc, char const *argv[])
{
system("pause");
return 0;
}*/
