/**
 * -*- coding : GBK -*-
 * @Author : huangshengjiang
 * @Email : 1005542693@qq.com
 * @Date : 2017-02-16 14:03
 * @Last Modified Date :      
 * @FileName : 最长公共子序列问题.cpp
 */

/*最长公共子序列问题
	基本概念 : 字符串A中任选x(从1到n)个元素按照原有顺序排列构成的所有序列,称为子序列.而字符串A和B相同子序列.
			   集合中最长的子序列长度,就是最长公共子序列.
	应用场景 : 相似度\重合度.例如论文查重,基因相似度,历史版本对比,模式识别(图像标签)高级版(将大量图像依据相似度程度
			   划分为几大聚类,设置标签,新添加的图像快速匹配对应的标签).
	具体需求 : 求出字符串A和B的最长公共子序列
		输入 : 字符串A和B
		输出 : A和B的最长公共子序列
		
	分析 : 首先单独看字符串A(n位)有2^n个子序列,B(m位)有2^m个子序列,例如A=abc,B=abedce 两者的公共子序列集合为
	{a,b,c,ab,ac,bc,abc},推测(特性) : 在A和B公共子序列集合中必然包含最长公共子序列的所有子序列(其他的公共子序列可有可无).

	解决方案1 : 正常思维是求出A的所有子序列2^n-1个,B有2^m-1个.每次从A的子序列集合中取出一个子序列x,将x与B的子序列集合
				比较相同,如果相同则放入公共子序列集合中,不同则舍弃.结束后,从公共子序列集合中查找并返回位数最多的子序列,
				该子序列就是最长的公共子序列.
		优缺点 : 简单明了,容易实现.但是时间复杂度是O(2^(n+m)),其中有大量的可简化部分.另外极度消耗计算机资源.
				 总体而言,需要改进.
		
	解决方案2 : 改进第一种方案,第一点 : 从A子序列集合中取出x,与B子序列集合全部比较的步骤.这其中花费大量无用计算.
				如1位的x和B中2\3\4位的比较.因此可以将B子序列集合分区,如1位区,2位区... ,计算x的位数,然后与B中的对应位区比较.
				第二点 : 公共子序列集合本身的特点:如果有子序列y,则y的所有子序列都包含于该公共子序列中.因此,x
				应该从A的n位区,n-2位区...1位区依次中选取.一旦x与B中对应的位区匹配成功,则可以返回(当然也有同样长度的子序列,
				可以将x此刻的位区与B对应位区对比一遍,再输出结果).
	   优缺点 : 虽然减少了大量不必要的对比时间,但是如果n = A.length > m = B.length .从m位区开始比较前,A和B都要分别计算出
				组合队列Cnm和Cmm个数量.计算m位区的组合队列消耗大量计算.可否利用分析中的特性减少组合队列的计算?

	解决方案3 : 参考教材,设A=a1a2a3..ai 和 B=b1b2b3...bj 的最长公共子序列为L[i,j].
				有L[i,j] = 0 当i=0或j=0
				有L[i,j] = L[i-1,j-1] + 1 当ai=bj && i>0 && j>0
				有L[i,j] = max{L[i-1,j],L[i,j-1]} 当ai!=bj && i>0 && j>0			
				则可以用二维数组L[n+1][m+1],存放A为i个,B为j个时的最长公共子序列的位数(不是求具体值)
				初始化L[i][0]和L[0][j]两侧为0.从左到右 从上到下 根据ai==bj计算L[i][j](理由是计算L[i,j]需要L[i-1,j],L[i,j-1],L[i-1,j-1])
				计算结束后,L[n][m]就是所求的位数值
	时间复杂度 : O(nm)
	空间复杂度 : O(nm)

	 引申问题 : 如果是字符串多个呢?如果要求出具体的字符串?
				1.字符串多个,可以用分治算法自下向上求解.
				2.具体的字符串值??不知道

	     结论 : 动态规划的问题主要是用于子问题之间有关联(一般为相同的子问题).如斐波那契数列(一维数组).
				特点都是设变量维度,找出与子问题的关系.
				而分治算法主要用于子问题相互独立的情况

 */
#include <iostream>
#include <string.h>
using namespace std;
//函数
int slength(char st[])
{
	int res = 0 ;
	while (st[res])
	{
		res++;
	}
	return res;
}

char St[801][801];  //缓冲空间,存放多个字符串 . 注 : 待写需要动态的变化
int  leng[801];     //存放对应字符串的长度
int  L[801][801];   //计算所需的空间,这只能用于两个字符串. 注 : 待写

//测试
//int main(int argc, char const *argv[])
//{
//	freopen("F:\\in.txt", "r", stdin);
//	int n ; 
//	scanf("%d",&n);
//	for (int i = 0 ; i < n ; i++)
//	{
//		scanf("%s",St[i]);
//		leng[i] = slength(St[i]);
//	}
//	//暂时计算两个字符串的值,计算需要整合成一个函数
//	for (int i = 0 ; i <= leng[0] ; i++)
//	{
//		L[i][0] = 0 ;
//	}
//	for (int j = 0 ; j <= leng[1] ; j++)
//	{
//		L[0][j] = 0 ;
//	}
//	for (int i = 1 ; i <= leng[0] ; i++)
//		for (int j = 1 ; j <= leng[1] ; j++)
//		{
//			if (St[0][i-1] == St[1][j-1])
//			{
//				L[i][j] = L[i-1][j-1] + 1 ;
//			}
//			else
//			{
//				L[i][j] = L[i-1][j] >= L[i][j-1] ? L[i-1][j] : L[i][j-1] ;
//			}
//		}
//
//	printf("%d",L[leng[0]][leng[1]]);
//
//
//	system("pause");
//	return 0;
//}
