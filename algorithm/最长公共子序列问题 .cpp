/**
 * -*- coding : GBK -*-
 * @Author : huangshengjiang
 * @Email : 1005542693@qq.com
 * @Date : 2017-02-16 14:03
 * @Last Modified Date :      
 * @FileName : 最长公共子序列问题.cpp
 */

/*最长公共子序列问题
	基本概念 : 字符串A中任选x(从1到n)个元素按照原有顺序排列构成的所有序列,称为子序列.而字符串A和B相同子序列.
			   集合中最长的子序列长度,就是最长公共子序列.
	应用场景 : 相似度\重合度.例如论文查重,基因相似度,历史版本对比,模式识别(图像标签)高级版(将大量图像依据相似度程度
			   划分为几大聚类,设置标签,新添加的图像快速匹配对应的标签).
	具体需求 : 求出字符串A和B的最长公共子序列
		输入 : 字符串A和B
		输出 : A和B的最长公共子序列
		
	分析 : 首先单独看字符串A(n位)有2^n个子序列,B(m位)有2^m个子序列,例如A=abc,B=abedce 两者的公共子序列集合为
	{a,b,c,ab,ac,bc,abc},推测 : 在A和B公共子序列集合中必然包含最长公共子序列的所有子序列(其他的公共子序列可有可无).
	
		时间复杂度 : 
		空间复杂度 : 
		简化 : 

	解决方案1 : 正常思维是求出A的所有子序列2^n-1个,B有2^m-1个.每次从A的子序列集合中取出一个子序列x,将x与B的子序列集合
				比较相同,如果相同则放入公共子序列集合中,不同则舍弃.结束后,从公共子序列集合中查找并返回位数最多的子序列,
				该子序列就是最长的公共子序列.
		优缺点 : 简单明了,容易实现.但是时间复杂度是O(2^(n+m)),其中有大量的可简化部分.另外极度消耗计算机资源.
				 总体而言,需要改进.
		
	解决方案2 : 改进第一种方案,第一点 : 从A子序列集合中取出x,与B子序列集合全部比较的步骤.这其中花费大量无用计算.
				如1位的x和B中2\3\4位的比较.因此可以将B子序列集合分区,如1位区,2位区... ,计算x的位数,然后与B中的对应位区比较.
				第二点 : 公共子序列集合本身的特点:如果有子序列y,则y的所有子序列都包含于该公共子序列中.因此,x
				应该从A的n位区,n-2位区...1位区依次中选取.一旦x与B中对应的位区匹配成功,则可以返回(当然也有同样长度的子序列,
				可以将x此刻的位区与B对应位区对比一遍,再输出结果).
		优缺点 : 

	引申问题 : 

	方案对比 : 

	结论 : 

 */
#include <iostream>
using namespace std;
//函数

//测试
/*int main(int argc, char const *argv[])
{
	system("pause");
	return 0;
}*/
